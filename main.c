/*!
@copyright

    Copyright (c) 2020, Kilian Kegel. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent

@brief

    This is the Microsoft LINK.EXE replacement to use the GNU linker
    "ld" to create Linux Applications in Visual Studio

@mainpage

    LinkLd

@section intro_sec Introduction

@section howto_sec HowTo

@file LinkLd.c

@todo
    20200819:   Add case match for Linux filenames
    20200819:   Currently the parameter translation is implemenied for the @commandfile only,
                that is generated by VisualStudio. Add that for the real command line too.
*/
#define _CRT_SECURE_NO_WARNINGS

#pragma warning(disable:4189) /* local variable is initialized but not referenced */
#pragma warning(disable:4706) /* assignment within conditional expression */

#include <stdio.h> 
#include <stdlib.h> 
#include <stdbool.h> 
#include <stdint.h>
#include <string.h> 
#include <ctype.h>
#include <limits.h>
#include <direct.h>
#include <windows.h>

typedef struct _CMDLINE_AND_FILE_PARAMETER 
{
    FILE* msgout;                                           // inside VisualStudio, print to STDERR, otherwise to STDOUT
    bool fLinuxLd;
    bool fPARMNologo;                                       // command line parameter "/nologo"
    bool fScriptCreated;
    bool fHelp;                                             // /? -? /h -h ...
    size_t sizeWin, sizeLnx, sizeLib, sizeScr, sizeObj;     //
    char* pParmWin, 
        * pParmFil, /* the command file appended with @*/
        * pCmdObj, 
        * pCmdLnx, 
        * pCmdScr, 
        * pCmdLib;    // NOTE:    GNU LD can use windows .LIB without any "--library" .so .a version 
                                                            //          number magic just by appending all library files AFTER the .OBJ files
    char* pszCmdLineFile;
    char* rgLibPathPtr[512];
    char* rgLibraryPtr[512];
    char  cwd[512];                                         //currend working directory
}CMDLINE_AND_FILE_PARAMETER;

static struct _PARMSUBSTTYPE0 {
    //
    // In TYPE0 SUBSTITUTION a "name + parameter" is directly appended 
    //
    bool  fFound;
    char* pSearch;
    char* pSubst;
}parmsubstT0[] = {
    {false, "/entry:"      ,"--entry "         },
};

static struct _PARMSUBSTTYPE1 {
    //
    // In TYPE1 SUBSTITUTION a "name" (path\file or functionname) is directly appended 
    //
    bool  fFound;
    char* pSearch;
    char* pSubst;
    char* pPathLnx;
    char* pPathWin;
}parmsubstT1[] = {
    {false, "/out:"        ,"--output "        ,NULL, NULL},
    {false, "/map:"        ,"-Map "            ,NULL, NULL},
    //{"/libpath:"    ,"--library-path "  },
};

//
// externals
//
extern volatile int deadloopint;

//
// protoptypes
//
char ld_script[];// GNU ld link script including MSFT specific section sequence for .CRT$...
char* Rel2AbsPath(const char* pstrRel, const char* pstrAbs, bool fBack2Slashes, bool fDrv2Mnt);
int Str2Argcv(char** argv, char* szCmdline);
int ProcessArgs(int xargc, char** xargv, CMDLINE_AND_FILE_PARAMETER* pstCommParm,bool fCmdFile);


#define LOWCASE(L) (('a' - 'A') | L)
#define ARGV_MAX 1024
#define EOS '\0'
#define EOSSIZE 1/*sizeof("");*/
#define ASCIICHRSPACE 0x20
#define ASCIISTRSPACE " "

#define INITPTR_T   = NULL
#define INITSIZE_T  = 0
#define INITINT_T   = 0
#define INITBOOL_T  = 0

void** FindFreePtr(void** rgLibraryPtr) {
    int i = 0;

    while (NULL != rgLibraryPtr[i])
        i++;

    return &rgLibraryPtr[i];
}

/**

Synopsis
    int main(int argc, char **argv);
Description
    LINK Hook.
    Check, if SUBSYSTEM:POSIX is selected and than translate LINK.exe parameter
    to "GNU ld" corresponding parameter and invoke "wsl ld" command.
    For all other SUBSYSTEMS call the real Microsoft LINK.exe
Returns
    real return value of LINK.exe or "GNU ld"

**/int main(int argc, char** argv, char **env)
{
    int nRet    INITINT_T, \
        k       INITINT_T, \
        l       INITINT_T;
    bool fVSBuild = NULL != getenv("VSSKUEDITION");     // depends on existance of VSSKUEDITION environment variable
                                                        // that is available only if building with Visual Studio
    int fargc;
    char** fargv = malloc(sizeof(void*) * ARGV_MAX);    // allocate buffer for 512 parameter
    char* pszMnt = NULL;
    
    static CMDLINE_AND_FILE_PARAMETER stCommParm;

    //
    // initialization
    //
    stCommParm.sizeWin = 1;
    memset(&stCommParm, 0, sizeof(stCommParm));
    stCommParm.sizeLnx = 1;
    stCommParm.sizeLib = 1;
    stCommParm.sizeScr = 1;
    stCommParm.sizeObj = 1;
    stCommParm.pParmWin = calloc(1, 1);
    stCommParm.pParmFil = calloc(1, 1);
    stCommParm.pCmdObj  = calloc(1,1);
    stCommParm.pCmdLnx  = calloc(1,1);
    stCommParm.pCmdScr  = calloc(1,1);
    stCommParm.pCmdLib  = calloc(1,1);
    stCommParm.msgout = 1 == fVSBuild ? stderr : stdout;    // inside VisualStudio, print to STDERR, otherwise to STDOUT
    _getcwd(stCommParm.cwd, sizeof(stCommParm.cwd));        // get current working directory

    /////////////////////////////////////////////
    // prerequisite
    /////////////////////////////////////////////
    if (0)  // 1 - enable DEAD loop for debug purpose only
    {
        while (0 == deadloopint)
            ;
    }

    //
    // print entire environment
    //
    if (0)
    {
        int i;
        for (i = 0; NULL != env[i]; i++)
            fprintf(stCommParm.msgout, "line %d -> %s\n", __LINE__, env[i]);
    }

    // 2. get full drive and path name of this LINK.EXE hook
    //    to differentiate it's path/location from the 
    //    "real" LINK.EXE to be hooked
    if (1)
    {
        static char    FName[512];
        unsigned lenFName = sizeof(FName);
        HMODULE hModule = NULL;

        GetModuleFileNameA(hModule, FName, lenFName);
        argv[0] = &FName[0];
    }

    strcpy(stCommParm.pParmWin, ""/*"link_org.exe "*/);

    //#define LD_CMD_LINE_INITIAL "wsl ld --sort-section=name -z=combreloc --script /mnt/a/ldscript "
#define LD_CMD_LINE_INITIAL "wsl ld "
    stCommParm.pCmdLnx = calloc(sizeof(LD_CMD_LINE_INITIAL), 1);
    strcpy(stCommParm.pCmdLnx, LD_CMD_LINE_INITIAL);

    stCommParm.sizeWin = EOSSIZE + strlen(stCommParm.pParmWin);
//    stCommParm.sizeFil = EOSSIZE + strlen(stCommParm.pParmFil);
    stCommParm.sizeLnx = EOSSIZE + strlen(stCommParm.pCmdLnx);
    stCommParm.sizeLib = EOSSIZE + strlen(stCommParm.pCmdLib);
    stCommParm.sizeObj = EOSSIZE + strlen(stCommParm.pCmdObj);
    stCommParm.sizeScr = EOSSIZE + strlen(stCommParm.pCmdScr);

    ///////////////////////////////////////////////////////////////////////
    // process the real command LINE
    ///////////////////////////////////////////////////////////////////////
    ProcessArgs(argc, argv, &stCommParm,/*fCmdFile*/ false);

    ///////////////////////////////////////////////////////////////////////
    // process the command FILE appended with "@"
    ///////////////////////////////////////////////////////////////////////
    if (NULL != stCommParm.pszCmdLineFile) {

        FILE* fp = fopen(stCommParm.pszCmdLineFile, "rb");
        size_t fsize = (size_t)-1, num;
        char* pzsFCmdLine;
        
        if (1)
        {
            FILE* fpwcp = fopen("C:\\Users\\kilia\\AppData\\Local\\Temp\\lnkcmdw.txt", "wb");    //kgtest; //fp wide copy
            int c;
            //
            // save a copy of the original file (UNICODE)
            //
            while (EOF != (c = getc(fp)))
                putc(c,fpwcp);
            fclose(fpwcp);
        }

        fp = fopen(stCommParm.pszCmdLineFile, "r");

        //
        // get the comand file to memory, NOTE: IT IS UTF-16
        //
        fseek(fp, 0, SEEK_END);
        fsize = ftell(fp);
        fseek(fp, 0, SEEK_SET);

        pzsFCmdLine = malloc(fsize);
        num = fread(pzsFCmdLine, 1, fsize, fp);

        //
        // this file is UTF-16, convert it to ASCII
        //
        for (k = 2/* 2 -> skip BOM Byte Order Mark */, l = 0; k < (int)num; l++, k += 2) {
            pzsFCmdLine[l] = pzsFCmdLine[k];
            
            if ('\r' == pzsFCmdLine[l] || '\n' == pzsFCmdLine[l])
                pzsFCmdLine[l] = '\x20';

            //fprintf(stCommParm.msgout, "%c", pzsFCmdLine[l]);   //debug
        }
        pzsFCmdLine[l] = '\0';

        fp = fopen("C:\\Users\\kilia\\AppData\\Local\\Temp\\lnkcmd.txt", "w");    //kgtest
        num = fwrite(pzsFCmdLine, 1, num/2, fp);
        fclose(fp);

        
        fargc = Str2Argcv(fargv, pzsFCmdLine);
        
        ProcessArgs(fargc, fargv, &stCommParm,/*fCmdFile*/ true);

    }
    //__debugbreak();
    if (1 == stCommParm.fPARMNologo)
    {
        fprintf(stCommParm.msgout, "Torito LINK -- Microsoft (R) LINK.EXE hook for GNU \"ld\"\n  See https://github.com/KilianKegel/torito-C-Library for details.\n");
    }
    
    if (true == stCommParm.fHelp)
    {
        stCommParm.fLinuxLd = false;
        fprintf(stCommParm.msgout, "Torito LINK -- Microsoft (R) LINK.EXE hook for GNU \"ld\"\n  See https://github.com/KilianKegel/torito-C-Library for details.\n");
    }

    if(stCommParm.fLinuxLd) do
    {
        unsigned u;
        char* pMap = NULL;
        //
        // 1. check, that WSL is installed on the build machine
        //
        fprintf(stderr, "line %d -->Linux build\n",__LINE__);
        if (1)
        {
            char* pTmpName = malloc(1024);
            char* pCmdLine = malloc(1024);

            tmpnam(pTmpName);
            strcpy(pCmdLine, "WSL exit > ");
            strcat(pCmdLine, pTmpName);
            strcat(pCmdLine, " 2>&1");

            nRet = system(pCmdLine);

            if (nRet)
            {
                //TODO: extract %TEMP% from environment variable
                //TODO: FILE* fpErr = fopen("%temp%\\wslpresencetest.log", "r");
                //TODO: int c;
                fprintf(stderr, "Torito LINK -- Microsoft (R) LINK.EXE hook for GNU \"ld\"\nSee https://github.com/KilianKegel/torito-C-Library for details.\n");
                fprintf(stderr, "ERROR: WSL, Windows Subsystem for Linux can not be started on this platform.\n");
                fprintf(stderr, "       Please install WSL2 on this platform or, if is already installed, run as administrator:\n\n");
                fprintf(stderr, "       \"bcdedit /set hypervisorlaunchtype auto\"\n");
                //TODO: do {
                //TODO:     c = fgetc(fpErr);
                //TODO:     fputc(c, stderr);
                //TODO: } while (c = EOF);
                //TODO: remove("%temp%\\wslpresencetest.log");
                exit(2);
            }
        }
        /*
        //
        // necessarily a MAP file is needed to find uninitialized variables in .BSS
        //
        for (u = 0; u < sizeof(parmsubstT1) / sizeof(parmsubstT1[0]); u++)
            if (0 == _stricmp(parmsubstT1[u].pSearch, "/map:"))
            {
                if (NULL == (pMap = parmsubstT1[u].pPathWin))
                    u = UINT_MAX;
                break;//for (u = 0; u < sizeof(parmsubstT1) / sizeof(parmsubstT1[0]); u++)
            }
        */
        //
        // try to assign libraries to it's matching library search path, LD doesn't support library-path for *.lib
        //
        if (1)
        {
            int ilib, ipth;
            char* pstrLib = NULL;
            char* pChk;

            //
            // run through LIBRARY file names
            //
            ilib = -1;
            while (stCommParm.rgLibraryPtr[++ilib])
            {
                pChk = Rel2AbsPath(stCommParm.rgLibraryPtr[ilib], NULL, false, false);    // return NULL, if LIBNAME.lib only w/o path

                if (NULL == pChk)                                   // LIBNAME only w/o leading path?
                {                                                   // yes
                    //
                    // run through LIBRARY SEARCH PATH names and test against 
                    //
                    ipth = -1;
                    while (stCommParm.rgLibPathPtr[++ipth])
                    {
                        //
                        // check if LIBNAME.lib + LIBRARY SEARCH PATH is a true file path
                        // 
                        pChk = Rel2AbsPath(stCommParm.rgLibraryPtr[ilib], stCommParm.rgLibPathPtr[ipth], false, false);   // generate D:\SEARCHPATH\LIBNAME.lib

                        if (NULL != pChk)                           // have D:\SEARCHPATH\LIBNAME.lib?
                        {                                           // yes
                            FILE* fp = fopen(pChk, "rb");           // try to open that D:\SEARCHPATH\LIBNAME.lib
                            if (fp) {                               // file is available
                                fclose(fp);                         // free file pointer
                                free(pChk);                         // free memory of combined D:\SEARCHPATH\LIBNAME.lib
                                //fprintf(stCommParm.msgout, "line %2d LIBPATH: \"%s\"\n", __LINE__, (char*)pChk);//debug
                                //
                                // generate /mnt/d/SEARCHPATH/LIBNAME.lib and append it to the command line
                                //
                                pChk = Rel2AbsPath(stCommParm.rgLibraryPtr[ilib], stCommParm.rgLibPathPtr[ipth], true, true);
                                stCommParm.sizeLib += strlen(pChk);
                                stCommParm.pCmdLib = realloc(stCommParm.pCmdLib, EOSSIZE + stCommParm.sizeLib);
                                strcat(stCommParm.pCmdLib, pChk);
                                strcat(stCommParm.pCmdLib, " ");
                                free(pChk);
                            }
                        }
                    }

                }
                else//if (NULL == pChk) // LIBNAME only w/o leading path?
                {
                    FILE* fp = fopen(pChk, "rb");           // try to open that E:\FULLYGIVEN\LIBNAME.lib
                    if (fp) {                               // file is available
                        fclose(fp);                         // free file pointer
                        free(pChk);                         // free memory of combined E:\FULLYGIVEN\LIBNAME.lib
                        //fprintf(stCommParm.msgout, "line %2d LIBPATH: \"%s\"\n", __LINE__, (char*)pChk);//debug
                        //
                        // generate /mnt/e/FULLYGIVEN/LIBNAME.lib and append it to the command line
                        //
                        pChk = Rel2AbsPath(stCommParm.rgLibraryPtr[ilib], NULL, true, true);
                        stCommParm.sizeLib += strlen(pChk);
                        stCommParm.pCmdLib = realloc(stCommParm.pCmdLib, EOSSIZE + stCommParm.sizeLib);
                        strcat(stCommParm.pCmdLib, pChk);
                        strcat(stCommParm.pCmdLib, " ");
                        free(pChk);
                    }
                }
            }
        }

        stCommParm.pCmdLnx = realloc(stCommParm.pCmdLnx, stCommParm.sizeLnx + stCommParm.sizeLib + stCommParm.sizeObj + stCommParm.sizeScr );
        strcat(stCommParm.pCmdLnx, stCommParm.pCmdScr);
        strcat(stCommParm.pCmdLnx, stCommParm.pCmdObj);
        strcat(stCommParm.pCmdLnx, stCommParm.pCmdLib);

        nRet = system(stCommParm.pCmdLnx);     // invoke GNU ld, the linux linker 

        fprintf(stCommParm.msgout, "\"%d\" Torito LINK -> %s\n", nRet, stCommParm.pCmdLnx);

    }while (0);//if(stCommParm.fLinuxLd) do
    
    //
    // currently torito-LINK can't invoke Microsoft Link.exe, to bind .EFI and .EXE
    //
    if (0 == stCommParm.fLinuxLd)
    {
        fprintf(stderr, "Torito LINK -- Microsoft (R) LINK.EXE hook for GNU \"ld\"\nSee https://github.com/KilianKegel/torito-C-Library for details.\n");
        fprintf(stderr, "ERROR: Don't use Torito LINK to bind executable other then Linux x86-64 .ELF\n");
        fprintf(stderr, "       Remove Torito LINK form the PATH. In Visual Studio remove:\n");
        fprintf(stderr, "       Project Properties\\\n");
        fprintf(stderr, "           Configuration Properties\\\n");
        fprintf(stderr, "               VC++ Directories\\\n");
        fprintf(stderr, "                   Executable Directories->\"path of Torito LINK\"\n");
    }

    if (0)
    {
        while (!stCommParm.fLinuxLd)
        {
            //
            // original Microsoft (R) LINK.EXE
            //
            char* pEntirePath, * pPath;
            char fLinkExeFound = 0;
            char* pLinkExe = NULL;
            char* pCmdWinQuoted = NULL;
            DWORD dwLastError = 0;

            //fprintf(stCommParm.msgout, "%s\n", argv[0]);//debug

            pEntirePath = getenv("path");

            pPath = strtok(pEntirePath, ";");

            while (pPath != NULL)
            {

                if (0 == _strnicmp(pPath, argv[0], strlen(pPath)))
                {   //TODO: argv[0] 
                    //fprintf(stCommParm.msgout, "SKIP: %s\n", pPath);//debug
                }
                else
                {
                    FILE* fp;

                    pLinkExe = malloc(strlen(pPath) + sizeof("\\link.exe")/* include termination ZERO!!! */);

                    strcpy(pLinkExe, pPath);
                    strcat(pLinkExe, "\\LINK.EXE");

                    fp = fopen(pLinkExe, "rb");
                    if (NULL != fp)
                    {
                        //
                        // in this path LINKE.EXE is present
                        //
                        //fprintf(stCommParm.msgout, "EXIST: %s\n", pLinkExe);//debug
                        fclose(fp);
                        fLinkExeFound = 1;
                        break;  //while (pPath != NULL)
                    }
                    else
                    {
                        //
                        // in this path LINKE.EXE is NOT present
                        //
                        //fprintf(stCommParm.msgout, "NOTEXIST: %s - %s\n", pLinkExe, strerror(errno));//debug
                    }

                    free(pLinkExe);
                    pLinkExe = NULL;
                }
                pPath = strtok(NULL, ";");
            }

            if (NULL != pLinkExe)
            {

                STARTUPINFOA        StartupInfo;
                PROCESS_INFORMATION ProcessInformation;
                BOOL fRet;
                char* pLinkExeQ/*uatated*/ = malloc(strlen(pLinkExe) + EOSSIZE + 2 * sizeof("\""));
                char* pEnvTrackerLess;
                size_t sizeEnv = 0;
                int i;
                char noenv[] = { 0,0 };

                //if (1)
                //{
                //    for (i = 0; NULL != env[i]; i++)
                //    {
                //        if (strncmp(env[i], ))
                //    }
                //}

                //printf("Hello \"CREATE\"\n");

                memset(&StartupInfo, 0, sizeof(StartupInfo));
                StartupInfo.cb = sizeof(StartupInfo);
                memset(&ProcessInformation, 0, sizeof(ProcessInformation));

                strcpy(pLinkExeQ, "\"");
                strcat(pLinkExeQ, pLinkExe);
                strcat(pLinkExeQ, "\"");

                fprintf(stCommParm.msgout, "Torito LINK -> %s %s\n", pLinkExeQ, stCommParm.pParmWin);

                fRet = CreateProcessA(
                    pLinkExe,
                    stCommParm.pParmWin,
                    NULL,                   // Process handle not inheritable
                    NULL,                   // Thread handle not inheritable
                    FALSE,                  // Set handle inheritance to FALSE
                    NORMAL_PRIORITY_CLASS /*| CREATE_NEW_CONSOLE /*| CREATE_NEW_PROCESS_GROUP*/, // creation flags
                    &noenv,                   // Use parent's environment block
                    NULL,                   // Use parent's starting directory 
                    &StartupInfo,           // Pointer to STARTUPINFO structure
                    &ProcessInformation     // Pointer to PROCESS_INFORMATION structure
                );


                if (fRet)
                {
                    // Wait until child process exits.
                    WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
                }
                else {
                    dwLastError = GetLastError();
                    fprintf(stCommParm.msgout, "LastError -> %08X\n", dwLastError);
                }
                //fprintf(stCommParm.msgout, "\"%d\" Torito LINK -> %s %s\n", fRet, pLinkExe, stCommParm.pCmdLnx);

                nRet = !fRet;

                if (0 /* TRACKER_INTERMEDIATE */)
                {
                    char* pDirTracker = getenv("TRACKER_INTERMEDIATE");
                    char* pFilepUnsuccessfulbuild = NULL;

                    if (NULL != pDirTracker)
                    {
                        pFilepUnsuccessfulbuild = malloc(EOSSIZE + strlen(pDirTracker) + sizeof("Unsuccessfulbuild") + sizeof("\\"));
                        strcpy(pFilepUnsuccessfulbuild, pDirTracker);
                        strcat(pFilepUnsuccessfulbuild, "\\unsuccessfulbuild");
                        remove(pFilepUnsuccessfulbuild);
                    }
                }

                if (0 /* TRACKER_RESPONSEFILE */)
                {
                    char* pFileTrackerResponse = getenv("TRACKER_RESPONSEFILE");

                    if (NULL != pFileTrackerResponse)
                    {
                        FILE* fp;
                        int c;

                        fp = fopen(pFileTrackerResponse, "r");

                        fprintf(stCommParm.msgout, "TRACKER_RESPONSEFILE-> %c\n", c);
                        do {
                            c = fgetc(fp);
                            if (0xFF != c && 0xFE != c && 0x00 != c)
                                fprintf(stCommParm.msgout, "%c", c);
                        } while (EOF != c);
                        fprintf(stCommParm.msgout, "\n\n");
                        fclose(fp);
                        remove(pFileTrackerResponse);

                    }

                }

                if (0)
                {
                    pCmdWinQuoted = malloc(sizeof("\"\"") + strlen(pLinkExe) + sizeof("\"") + sizeof("\t") + strlen(stCommParm.pParmWin) + sizeof("\"") + EOSSIZE);
                    pLinkExe = realloc(pLinkExe, strlen(pLinkExe) + strlen(stCommParm.pParmWin) + EOSSIZE);

                    strcpy(pCmdWinQuoted, "");
                    strcpy(pCmdWinQuoted, "\"");
                    strcat(pCmdWinQuoted, pLinkExe);
                    strcat(pCmdWinQuoted, "\"");

                    //nRet = system(pCmdWinQuoted);
                    //"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\HostX86\x64\linK.EXe" /nologo  /ERRORREPORT:PROMPT @C:\Users\kilia\AppData\Local\Temp\tmp59f7e5dc2b8c493fa6834c277a69f298.rsp /INCREMENTAL:NO /NOLOGO /LIBPATH:..\libraries kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /NODEFAULTLIB /MANIFEST:NO /DEBUG:FULL /PDB:"A:\Visual-ANSI-C-for-UEFI-Shell2\x64\UEFIx86-64 (Torito C Library)\argcv.pdb" /MAP:"A:\Visual-ANSI-C-for-UEFI-Shell2\x64\UEFIx86-64 (Torito C Library)\argcv.map" /MAPINFO:EXPORTS /SUBSYSTEM:EFI_APPLICATION /OPT:REF /OPT:ICF /LTCG:incremental /TLBID:1 /ENTRY:_MainEntryPointShell /DYNAMICBASE:NO /FIXED:NO /NXCOMPAT:NO /MACHINE:X64 ..\libraries\toritoC64R.lib "x64\UEFIx86-64 (Torito C Library)\argcv.obj"
                    //strcat(pCmdWinQuoted, " /nologo ");
                    strcat(pCmdWinQuoted, " ");
                    //strcat(pCmdWinQuoted, "\t");

                    strcat(pCmdWinQuoted, stCommParm.pParmWin);

                    //__debugbreak();
                    //
                    // remove trailing blanks
                    //
                    if (1)
                    {
                        size_t len = strlen(pCmdWinQuoted);

                        while (
                            0 != len &&
                            (
                                '\t' == pCmdWinQuoted[len] ||
                                '\n' == pCmdWinQuoted[len] ||
                                '\r' == pCmdWinQuoted[len] ||
                                '\x00' == pCmdWinQuoted[len] ||
                                '\x20' == pCmdWinQuoted[len]
                                )
                            )
                        {
                            len--;
                        }

                        pCmdWinQuoted[1 + len] = '\0';

                    }
                    strcat(pCmdWinQuoted, "");


                    fprintf(stCommParm.msgout, "\n\nTorito LINK -> %s\n\n", pCmdWinQuoted);
                    //fprintf(stCommParm.msgout, "\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.27.29110\\bin\\HostX86\\x64\\LINK.EXE\" @C:\\Users\\kilia\\AppData\\Local\\Temp\\lnkcmdw.txt");
                    fflush(stCommParm.msgout);

                    nRet = 0;
                    fprintf(stCommParm.msgout, "!>>>\n"); fflush(stCommParm.msgout);
                    nRet = system(pCmdWinQuoted);
                    fprintf(stCommParm.msgout, "!<<< nRet %d\n", nRet); fflush(stCommParm.msgout);
                    //nRet = system("\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.27.29110\\bin\\HostX86\\x64\\LINK.EXE\" @C:\\Users\\kilia\\AppData\\Local\\Temp\\lnkcmdw.txt");
                }
            }
            else {
                fprintf(stCommParm.msgout, "Torito LINK -- Microsoft (R) LINK.EXE hook for GNU \"ld\"\n  See https://github.com/KilianKegel/torito-C-Library for details.\n");
                fprintf(stCommParm.msgout, "ERROR: LINK.EXE not found. Maybe the Microsoft Visual Studio 2019 build environment\n");
                fprintf(stCommParm.msgout, "       not / or incorrectly installed on this platform.\n\n");
                nRet = 1;   // return error
            }
            fprintf(stCommParm.msgout, "LaSTeRRoR -> %08X; nRet %d\n", dwLastError, nRet);
            break;//while(!fLinuxLd)

        }
    }
    exit(nRet);
    return nRet;
}

/**

Synopsis
    int ProcessArgs(int xargc, char** xargv, CMDLINE_AND_FILE_PARAMETER *pstCommParm, bool fCmdFile, bool fCmdFile) );
Description
    Translate LINK.EXE command line parameters to GNU ld command line parameters.
    Prepare a command line to invoke Microsoft LINK.EXE too.
    *pstCommParm structure elements is updated 

Returns

    @retval argc

**/
int ProcessArgs(int xargc, char** xargv, CMDLINE_AND_FILE_PARAMETER *pstCommParm, bool fCmdFile/*command file*/) 
{
    int i,j,nRet = 0;
    for (i = (true == fCmdFile ? 0 : 1) /* skip filename */; i < xargc; i++) {

        //fprintf(pstCommParm->msgout, "line %2d->%2d, fCmdFile %d: %s\n", __LINE__, i, fCmdFile, xargv[i]);//debug

        //
        // re-create the original command line to pass it to Microsoft LINK.exe 
        //
        if (false == fCmdFile)
        {
            bool fCase0, fCase1, fCase2;    //flags
            size_t orgLen, tmpLen;
            //pstCommParm->pParmWin = realloc(
            //    pstCommParm->pParmWin, 
            //    strlen(xargv[i]) + 
            //    strlen(pstCommParm->pParmWin) +
            //    strlen(" ") +       /* separation space */
            //    2 * strlen("\"") +  /* enclose each parameter in " */
            //    EOSSIZE);
            //
            // enclose path\filennames, containing spaces, into quotation mark
            //  algorithm:
            //      0)  check, if the particular argv[i] contains spaces
            //      1)  check, if a parameter starts with a slash "/" or stroke "-"
            //      2)  in case of (0) AND (1) check for colon ":"
            //      3)  in case of (0) AND (1) AND (2) enclose the substring AFTER colon ":" in quotation mark
            //          finish!
            //      4)  in case of (0) AND NOT (1) enclose the entire argv[i] in quotation mark
            //          finish!
            //      5)  

            orgLen = EOSSIZE + strlen(pstCommParm->pParmWin);                                // get current length
            pstCommParm->pParmWin = realloc(
                pstCommParm->pParmWin,
                orgLen + strlen(xargv[i]) +
                EOSSIZE +
                strlen(" ") +       /* separation space */
                2 * sizeof('\"')    // even if not needed, allocate space for two additional quotation marks
            );

            fCase0 = (NULL != strchr(xargv[i], ASCIICHRSPACE));
            if (fCase0) {


                fCase1 = (('/' == xargv[i][0]) || ('-' == xargv[i][0]));
                if (fCase1) {
                    fCase2 = (NULL != strchr(xargv[i], ':'));
                    if (fCase2) {

                        //__debugbreak();
                        tmpLen = strcspn(xargv[i], ":");
                        strncpy(&pstCommParm->pParmWin[orgLen], xargv[i], tmpLen + 1);
                        pstCommParm->pParmWin[orgLen + tmpLen + 1] = '\0';
                        strcat(pstCommParm->pParmWin, "\"");
                        strcat(pstCommParm->pParmWin, &xargv[i][tmpLen + 1]);
                        strcat(pstCommParm->pParmWin, "\"");
                    }
                }
                else
                {
                    // 4)
                    strcat(pstCommParm->pParmWin, "\"");
                    strcat(pstCommParm->pParmWin, xargv[i]);
                    strcat(pstCommParm->pParmWin, "\"");
                }
            }
            else {
                strcat(pstCommParm->pParmWin, xargv[i]);
            }
        }
        strcat(pstCommParm->pParmWin, " "); /* separation space */

        if ('@' == xargv[i][0])
            pstCommParm->pszCmdLineFile = &xargv[i][1];

        if (0 == _stricmp("/NOLOGO", xargv[i]))
            pstCommParm->fPARMNologo = 0;
        if (0 == _stricmp("/?", xargv[i]) ||
            0 == _stricmp("-?", xargv[i]) ||
            0 == _stricmp("/h", xargv[i]) ||
            0 == _stricmp("-h", xargv[i]) ||
            0 == _stricmp("-h", xargv[i]))
        {
            pstCommParm->fHelp = true;
            xargv[i] = "/?";
        }

        if (0 != _stricmp("/SUBSYSTEM:POSIX", xargv[i]))
        {
            char fFileTypeIsOBJ;
            char fFileTypeIsLIB = false;

            //
            // process T0/TYPE0 substitution -> replace "/entry:_CRT0" by "--entry _CRT0"
            //
            for (j = 0; j < sizeof(parmsubstT0) / sizeof(parmsubstT0[0]); j++)
            {
                //
                // check for parameter replacement "/entry:" -> "-e "
                //
                if (0 == _strnicmp(parmsubstT0[j].pSearch, xargv[i], strlen(parmsubstT0[j].pSearch)))
                {
                    int x;
                    //
                    // find index of naked path
                    //
                    int iPathName = (int)strlen(parmsubstT0[j].pSearch);
                    char* strsnippet[] = {
                        parmsubstT0[j].pSubst,
                        "\"",
                        &xargv[i][iPathName],
                        "\"",
                        " ",            /* append separation space      */
                    };

                    for (x = 0; x < sizeof(strsnippet) / sizeof(strsnippet[0]); x++)
                    {
                        pstCommParm->sizeLnx += strlen(strsnippet[x]);
                        pstCommParm->pCmdLnx = realloc(pstCommParm->pCmdLnx, EOSSIZE + pstCommParm->sizeLnx);
                        strcat(pstCommParm->pCmdLnx, strsnippet[x]);
                    }
                }
            }

            //
            // process T1/TYPE1 substitution -> replace "/out:" by "-o "
            //
            for (j = 0; j < sizeof(parmsubstT1) / sizeof(parmsubstT1[0]); j++)
            {
                //
                // check for parameter replacement "/OUT:" -> "-o", "/MAP:" -> "-Map", "/entry:" -> "-e "
                //
                if (0 == _strnicmp(parmsubstT1[j].pSearch, xargv[i], strlen(parmsubstT1[j].pSearch)))
                {
                    int x;
                    //
                    // find index of naked path
                    //
                    int iPathName = (int)strlen(parmsubstT1[j].pSearch);
                    //
                    // translate path
                    //
                    char* pAbsLnxPath = Rel2AbsPath(&xargv[i][iPathName], pstCommParm->cwd, true, true);
                    char* strsnippet[] = {
                        parmsubstT1[j].pSubst,
                        "\"",
                        pAbsLnxPath,
                        "\"",
                        " ",            /* append separation space      */
                    };

                    for (x = 0; x < sizeof(strsnippet) / sizeof(strsnippet[0]); x++)
                    {
                        pstCommParm->sizeLnx += strlen(strsnippet[x]);
                        pstCommParm->pCmdLnx = realloc(pstCommParm->pCmdLnx, EOSSIZE + pstCommParm->sizeLnx);
                        strcat(pstCommParm->pCmdLnx, strsnippet[x]);
                    }
                    parmsubstT1[j].pPathLnx = pAbsLnxPath;
                    parmsubstT1[j].pPathWin = &xargv[i][iPathName];
                    parmsubstT1[j].fFound = true;

                }
            }

            //
            // append OBJ files
            //
            fFileTypeIsOBJ = 0 == _stricmp(".obj", &xargv[i][strlen(xargv[i]) - strlen(".obj")]);
            if (true == fFileTypeIsOBJ)
            {
                int x;
                char cwdbuf[256] = "";
                char* pCWD = _getcwd(cwdbuf, sizeof(cwdbuf));
                //
                // translate path
                //
                char* pAbsLnxPath = Rel2AbsPath(&xargv[i][0], pCWD, true, true);
                char* strsnippet[] =
                {
                    "\"",           /* enclose ...                  */
                    pAbsLnxPath,    /* ... OBJ filename ...         */
                    "\"",           /* ... with quotation marks     */
                    " ",            /* append separation space      */
                };

                for (x = 0; x < sizeof(strsnippet) / sizeof(strsnippet[0]); x++)
                {
                    pstCommParm->sizeObj += strlen(strsnippet[x]);
                    pstCommParm->pCmdObj = realloc(pstCommParm->pCmdObj, EOSSIZE + pstCommParm->sizeObj);
                    strcat(pstCommParm->pCmdObj, strsnippet[x]);
                }
            }

            //
            // create the LD_SCRIPT in the same directory of the .OBJ
            //
            if (false == pstCommParm->fScriptCreated && 
                true == fFileTypeIsOBJ )
            {
                size_t w;
                FILE* fp;
                int x;
                char cwdbuf[256] = "";
                char* pCWD = _getcwd(cwdbuf, sizeof(cwdbuf));
                    //, \
                    //* pScr;     // address where to overwrite "ldscript.scr" instead .OBJ filename
                static char strLdscriptName[512];
                
                tmpnam(&strLdscriptName[0]);

                //
                // translate path
                //                              
                char* pAbsLnxPath = Rel2AbsPath(strLdscriptName, NULL, true, true);
                char* pAbsWinPath = Rel2AbsPath(strLdscriptName, NULL, false, false);
                //char* pAbsLnxPath = Rel2AbsPath(&xargv[i][0], pCWD, true, true);
                //char* pAbsWinPath = Rel2AbsPath(&xargv[i][0], pCWD, false, false);
                char* strsnippetWin[] =
                {
                    "\"",           /* enclose ...                  */
                    pAbsWinPath,    /* ... OBJ filename ...         */
                    "\" ",          /* ... with quotation marks     *//* append separation space      */
                };
                char* strsnippetLnx[] =
                {
                    "--script \"",  /* enclose ...                  */
                    pAbsLnxPath,    /* ... OBJ filename ...         */
                    "\" ",          /* ... with quotation marks     *//* append separation space      */
                };

                pstCommParm->fScriptCreated = true;

                //if (0)  // replace .OBJ filename by tmpnam generated name in the Windows Path
                //{
                //    pScr = strrchr(pAbsWinPath, '\\');

                //    if (NULL != pScr)
                //        strcpy(&pScr[1], strLdscriptName);
                //    else
                //        strcpy(pAbsWinPath, strLdscriptName);
                //}

                //if (0)  // replace .OBJ filename by tmpnam generated name in the Windows Path
                //{
                //    pScr = strrchr(pAbsLnxPath, '/');

                //    if (NULL != pScr)
                //        strcpy(&pScr[1], strLdscriptName);
                //    else
                //        strcpy(pAbsWinPath, strLdscriptName);
                //}

                for (x = 0; x < sizeof(strsnippetLnx) / sizeof(strsnippetLnx[0]); x++)
                {
                    pstCommParm->sizeScr += strlen(strsnippetLnx[x]);
                    pstCommParm->pCmdScr = realloc(pstCommParm->pCmdScr, EOSSIZE + pstCommParm->sizeScr);
                    strcat(pstCommParm->pCmdScr, strsnippetLnx[x]);
                }
                //strcpy(pCmdScr, " ");//debug
                if (1)
                {

                    //fprintf(stderr, "-->> %s\n", pAbsWinPath);//debug
                    fp = fopen(pAbsWinPath, "w");
                    if (NULL != fp)
                    {
                        w = fwrite(ld_script, 1, strlen(ld_script), fp);
                        fclose(fp);
                    }
                }
            }


            //
            // ATTENTION: append LIB files at the very end of the command line
            //
            if (0 == _stricmp(".lib", &xargv[i][strlen(xargv[i]) - strlen(".lib")]))    // check .lib extention at the end
                fFileTypeIsLIB = true;
            if (0 == _strnicmp("/IMPLIB:", xargv[i], sizeof("/IMPLIB:") - 1))
                fFileTypeIsLIB = false;
            if (true == fFileTypeIsLIB)
            {
                void** p = FindFreePtr(&pstCommParm->rgLibraryPtr[0]);
                char* pc = Rel2AbsPath(xargv[i], pstCommParm->cwd, 0, 0);

                if (NULL == pc)
                {
                    pc = malloc(1 + strlen(xargv[i]));
                    strcpy(pc, xargv[i]);
                }

                *p = pc;

                //fprintf(pstCommParm->msgout, "line %2d LIBRARY: \"%s\"\n", __LINE__, (char*)*p);//debug
            }

            //
            // /LIBPATH:
            //
            if (0 == _strnicmp("/LIBPATH:", xargv[i], sizeof("/LIBPATH:") - 1))
            {
                void** p = FindFreePtr(&pstCommParm->rgLibPathPtr[0]);
                char* pc = malloc(1 + strlen(&xargv[i][strlen("/LIBPATH:")]));

                strcpy(pc, &xargv[i][strlen("/LIBPATH:")]);
                *p = pc;
                //fprintf(pstCommParm->msgout, "line %2d LIBPATH: \"%s\"\n", __LINE__, (char*)*p);//debug
            }
        }
        else
            pstCommParm->fLinuxLd |= true;
    }//for (i = 0; i < xargc; i++) {
    
    return nRet;
}

/**

Synopsis
    char* Rel2AbsPath(const char* pstrRel, const char *pstrAbs, bool fBack2Slashes, bool fDrv2Mnt);
Description
    convert relative path to absolute path and allows substition of drive numbers (a:, B: c:...) with LINUX mount locations (/mnt/a, /mnt/b ...)

    @param[in] const char* pRel             -   1) a:\bcd
                                                2) a:\bcd\..\efg
                                                3) \hij
                                                4) \klm\..\nop
                                                5) .\qrs
                                                6) ..\tuv
                                                7) \\network\hij
    @param[in] const char *pRoot            -   1) a:
                                                2) a:\
                                                2) a:\abc\
                                                NOTE: 1)    drive relative path is not accepted and ALWAYS appended by one BACKSLASH
                                                            to make it absolute
    @param[in] bool fBack2Slashes           -   0 slashes 2 backslashes
                                                1 backslaches 2 slashes
    @param[in] bool fDrv2Mnt                -   0 don't subst drive name to mount directory
                                                1 do!!! subst drive name to mount directory
Returns
    @retval pstrFullPath on SUCCESS
            NULL on FAILURE
**/
char* Rel2AbsPath(const char* pstrRel, const char* pstrAbs, bool fBack2Slashes, bool fDrv2Mnt)
{
    char* pRet = NULL;
    //char* pAbsPath = calloc(1, 1);
    size_t SizeAbsPath = 1;
    size_t n;
    char* pstr = NULL;// malloc(0);
    char* pstrCur, * pstrStart;


    enum PATHTYPE
    {
        UNKDIR = 0/*                                                          */,
        FULLDIR /* a:\abc           pstrAbs not incorporated into pstrRel  */,
        NETDIR  /* \\NET\share\...  pstrAbs not incorporated into pstrRel  */,
        //TODO drv rel path:DRVDIR  /* a:abc            pstrAbs     incorporated into pstrRel  */,
        ROOTDIR /* \abc\...         pstrAbs     incorporated into pstrRel  */,
        PARDIR  /* ..\abc\...       pstrAbs     incorporated into pstrRel  */,
        CURDIR  /* .\abc\...        pstrAbs     incorporated into pstrRel  */,
        CURDIR2 /* local\abc\...    pstrAbs     incorporated into pstrRel  */,
        // DON'T add PATHTYPE symbols beyond this line
    };

    enum PATHTYPE pathtype = UNKDIR;
    do
    {
        //
        // 1. determine path type 
        //
        if (pathtype = UNKDIR)  // assign a 0
            ;
        else if (1 == strspn(&pstrRel[0], "\\"))                                    // \xcv -> rootdir
            pathtype = ROOTDIR;                                                     //
        else if (2 == strspn(&pstrRel[0], "\\"))                                    // \\net-> network
            pathtype = NETDIR;                                                      //
        else if (1 == strspn(&pstrRel[0], "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") &&
            1 == strspn(&pstrRel[1], ":") && 1 == strspn(&pstrRel[2], "\\"))// x:\  -> drive
            pathtype = FULLDIR;                                                     //
        else if (2 == strspn(&pstrRel[0], ".") && 1 >= strspn(&pstrRel[2], "\\"))   // ..\  -> parent
            pathtype = PARDIR;                                                      //
        else if (1 == strspn(&pstrRel[0], ".") && 1 >= strspn(&pstrRel[1], "\\"))   // .\   -> local
            pathtype = CURDIR;                                                      //
        else if (NULL != strpbrk(&pstrRel[0], "\\"))                                // local\folder -> local
            pathtype = CURDIR2;

        if (UNKDIR == pathtype && NULL == pstrAbs)    // assign a 0
            break;
        //
        // check if pstrAbs is required. It is NOT required for NETDIR and FULLDIR
        //
        if (NULL == pstrAbs || NETDIR == pathtype || FULLDIR == pathtype)
            pstrAbs = "";

        //
        // merge RelPath and RootPath, if required
        //
        n = strlen(pstrRel) + sizeof('\\') + strlen(pstrAbs) + sizeof('\\') + EOSSIZE;

        pstr = realloc(pstr, n);

        strcpy(pstr, pstrAbs);
        n = strlen(pstr);
        if (0 != n)
            if('\\'!= pstr[n - 1])  // don't append backslash twice
                strcat(pstr, "\\");
        strcat(pstr, pstrRel);
        strcat(pstr, "\\");

        //
        // 2. determine path type after merging with pstrAbs
        //
        if (pathtype = UNKDIR)  // assign a 0
            ;
        else if (1 == strspn(&pstr[0], "\\"))                                       // \xcv -> rootdir
            pathtype = ROOTDIR;                                                     //
        else if (2 == strspn(&pstr[0], "\\"))                                       // \\net-> network
            pathtype = NETDIR;                                                      //
        else if (1 == strspn(&pstr[0], "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") &&
            1 == strspn(&pstr[1], ":") && 1 == strspn(&pstr[2], "\\"))      // x:\  -> drive
            pathtype = FULLDIR;                                                     //
        else if (2 == strspn(&pstr[0], ".") && 1 >= strspn(&pstr[2], "\\"))         // ..\  -> parent
            pathtype = PARDIR;                                                      //
        else if (1 == strspn(&pstr[0], ".") && 1 >= strspn(&pstr[1], "\\"))         // .\   -> local
            pathtype = CURDIR;                                                      //
        else if (NULL != strpbrk(&pstr[0], "\\"))                                   // local\folder -> local
            pathtype = CURDIR2;

        if (UNKDIR == pathtype)    // assign a 0
            break;
        //
        // find path string beyond network share bachslashes or drive name
        //
        n = strspn(&pstr[1], ".:\\");
        pstrStart = &pstr[n + 1];

        //
        // remove "\\\\"
        //
        while (NULL != (pstrCur = strstr(pstrStart, "\\\\")))
            strcpy(pstrCur, &pstrCur[sizeof("\\") - EOSSIZE])/*, printf("%03d: %s\n", __LINE__, pstrStart)*/;
        //
        // remove "\.\"
        //
        while (NULL != (pstrCur = strstr(pstrStart, "\\.\\")))
            strcpy(&pstrCur[1], &pstrCur[sizeof("\\.\\") - EOSSIZE])/*, printf("%03d: %s\n", __LINE__, pstrStart)*/;
        //
        // process "\..\"
        //
        while (NULL != (pstrCur = strstr(pstrStart, "\\..\\")))
        {
            ptrdiff_t i;

            i = pstrCur - pstrStart;
            while (--i > -1LL)
                if ('\\' == pstrStart[i])
                    break;
            strcpy(&pstrStart[i + 1], &pstrCur[sizeof("\\..\\") - EOSSIZE]);
            //printf("%03d: %s, %td\n", __LINE__, pstrStart, i);        
        }
        //
        // check, that path is not lead by '.' or single '\\'
        //
        if (0 != strspn(pstr, "."))
            break;  // return pRet == NULL
        if (1 == strspn(pstr, "\\"))
            break;  // return pRet == NULL

        //
        // replace drive name "x:" "by /mnt/x"
        //
        if (true == fDrv2Mnt && NETDIR != pathtype)
        {
            int drive = tolower(pstr[0]);

            if (0 != isalpha(drive))
            {
                size_t strsft = strlen("/mnt/#");   //string shift to insert "/mnt/#" at the beginning

                pstr = realloc(pstr, strlen(pstr) + EOSSIZE + sizeof("/mnt/#") - sizeof("A:"));
                memmove(&pstr[strsft], &pstr[2], strlen(&pstr[2]) + EOSSIZE);
                strncpy(&pstr[0], "/mnt/#", sizeof("/mnt/#") - EOSSIZE);
                pstr[strsft - 1] = (char)drive;
            }
            else
                break;  // return pRet == NULL
        }

        //
        // swap backslashes to slashes
        //
        if (true == fBack2Slashes && NULL != pstr)
        {
            int i = -1;

            while (pstr[++i])
                if ('\\' == pstr[i])
                    pstr[i] = '/';
        }
        //
        // remove trailing slash / backslash
        //
        pstr[strlen(pstr) - 1] = '\0';

        pRet = pstr;

    } while (0);

    if (NULL == pRet)
        free(pstr);

    return pRet;
}
/**

Synopsis
    int Str2Argcv(char **argv,char *szCmdline);
Description
    chop up a string in a argc/argv equivalent.
Returns

    @param[in] char **argv
    @param[in] char szCmdLine

    @retval argc

**/
int Str2Argcv(char** argv, char* szCmdline) {

    int fBStore = 0/*blank store vs. copy*/;
    int fSStore = 1/*separator store*/;
#define ISBLANK(x) (0x20 == x || '\t' == x)
#define ISSLASH(x) ('\\' == x)
#define ISQUOTE(x) ('"' == x)
#define DELIM 1
    int nSlashBack = 0;
    char* pSrc = szCmdline, * pDst = &pSrc[-1];
    int argc = 0;
    enum STATE {
        PROCESS_BEGIN,/*eat leading blanks...*/
        PROCESS_BLANKS/*skip or store blanks*/,
        PROCESS_NONBLANKS,
        PROCESS_SLASHBACK,
        PROCESS_EVEN_SLASHBACK_QUOTATION,
        PROCESS_ODD_SLASHBACK_QUOTATION,
        PROCESS_DELIMITER,
        PROCESS_SLASHBACKSTORAGE,
        PROCESS_QUOTATION
    }state = PROCESS_BLANKS, old;

    while (*pSrc || state == PROCESS_SLASHBACKSTORAGE ||
        state == PROCESS_ODD_SLASHBACK_QUOTATION ||
        state == PROCESS_EVEN_SLASHBACK_QUOTATION ||
        state == PROCESS_SLASHBACK)
    {
        old = state;
        switch (state) {

        case PROCESS_BEGIN:
            if (!ISBLANK(*pSrc))
                state = PROCESS_NONBLANKS;
            break;

        case PROCESS_BLANKS:
            if (ISBLANK(*pSrc)) {
                if (fBStore)
                    *++pDst = *pSrc;
                else
                    if (fSStore)
                        fSStore = 0,
                        * ++pDst = DELIM;
            }
            else
                fSStore = 1,
                state = PROCESS_NONBLANKS;
            break;

        case PROCESS_NONBLANKS:

            state = ISSLASH(*pSrc) ? PROCESS_SLASHBACK : state;
            state = ISQUOTE(*pSrc) ? PROCESS_QUOTATION : state;
            state = ISBLANK(*pSrc) ? PROCESS_BLANKS : state;

            if (state != PROCESS_NONBLANKS)
                break;
            *++pDst = *pSrc;
            break;

        case PROCESS_SLASHBACK:

            if (ISSLASH(*pSrc)) {
                nSlashBack++;
                break;
            }

            if (ISQUOTE(*pSrc)) {
                state = nSlashBack % 2 ? PROCESS_ODD_SLASHBACK_QUOTATION : PROCESS_EVEN_SLASHBACK_QUOTATION;
                nSlashBack /= 2;
                pSrc++;
            }
            else
                state = PROCESS_SLASHBACKSTORAGE;

            break;

        case PROCESS_QUOTATION:
            fBStore = !fBStore;
            state = PROCESS_BLANKS;
            //hack for "" at end of string
            if (0 == fBStore && '\0' == pSrc[1])
                *++pDst = DELIM;
            break;

        case PROCESS_SLASHBACKSTORAGE:
        case PROCESS_ODD_SLASHBACK_QUOTATION:
        case PROCESS_EVEN_SLASHBACK_QUOTATION:
            while (nSlashBack--)
                *++pDst = '\\';
            if (state == PROCESS_ODD_SLASHBACK_QUOTATION)
                *++pDst = '"';
            if (state != PROCESS_SLASHBACKSTORAGE)
                fBStore = state == PROCESS_EVEN_SLASHBACK_QUOTATION ? !fBStore : fBStore;
            nSlashBack = 0;
            state = PROCESS_BLANKS;
            break;
        }

        if (old == state || (old == PROCESS_QUOTATION && state == PROCESS_BLANKS))
            pSrc++;
    }//while(*pSrc)

    if (*pDst != DELIM || fBStore)
        *++pDst = DELIM;
    *++pDst = '\0';

    for (argc = 0, pSrc = szCmdline; *pSrc != '\0' && argc < ARGV_MAX; argc++) {
        argv[argc] = pSrc;
        while (*pSrc++ != DELIM)
            ;
        pSrc[-1] = '\0';
    }

    return argc;
}

char ld_script[] =
{
"/* Script for -z combreloc -z separate-code */\n"
"/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n"
"   Copying and distribution of this script, with or without modification,\n"
"   are permitted in any medium without royalty provided the copyright\n"
"   notice and this notice are preserved.  */\n"
"OUTPUT_FORMAT(\"elf64-x86-64\", \"elf64-x86-64\",\n"
"	      \"elf64-x86-64\")\n"
"OUTPUT_ARCH(i386:x86-64)\n"
"ENTRY(_start)\n"
"SEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib64\"); SEARCH_DIR(\"/usr/local/lib64\"); SEARCH_DIR(\"/lib64\"); SEARCH_DIR(\"/usr/lib64\"); SEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\n"
"SECTIONS\n"
"{\n"
"  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n"
"  .interp         : { *(.interp) }\n"
"  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n"
"  .hash           : { *(.hash) }\n"
"  .gnu.hash       : { *(.gnu.hash) }\n"
"  .dynsym         : { *(.dynsym) }\n"
"  .dynstr         : { *(.dynstr) }\n"
"  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n"
"  .rela.dyn       :\n"
"    {\n"
"      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n"
"      *(.rela.fini)\n"
"      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n"
"      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n"
"      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n"
"      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n"
"      *(.rela.ctors)\n"
"      *(.rela.dtors)\n"
"      *(.rela.got)\n"
"      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n"
"      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n"
"      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n"
"      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n"
"      *(.rela.ifunc)\n"
"    }\n"
"  .rela.plt       :\n"
"    {\n"
"      *(.rela.plt)\n"
"      PROVIDE_HIDDEN (__rela_iplt_start = .);\n"
"      *(.rela.iplt)\n"
"      PROVIDE_HIDDEN (__rela_iplt_end = .);\n"
"    }\n"
"  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  .init           :\n"
"  {\n"
"    KEEP (*(SORT_NONE(.init)))\n"
"  }\n"
"  .plt            : { *(.plt) *(.iplt) }\n"
".plt.got        : { *(.plt.got) }\n"
".plt.sec        : { *(.plt.sec) }\n"
"  .text           :\n"
"  {\n"
"    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n"
"    *(.text.exit .text.exit.*)\n"
"    *(.text.startup .text.startup.*)\n"
"    *(.text.hot .text.hot.*)\n"
"    *(SORT(.text.sorted.*))\n"
"    *(.text .stub .text.* .gnu.linkonce.t.*)\n"
"    /* .gnu.warning sections are handled specially by elf.em.  */\n"
"    *(.gnu.warning)\n"
"  }\n"
"  .fini           : \n"
"  {\n"
"    KEEP (*(SORT_NONE(.fini)))\n"
"  }\n"
"  PROVIDE (__etext = .);\n"
"  PROVIDE (_etext = .);\n"
"  PROVIDE (etext = .);\n"
"  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  /* Adjust the address for the rodata segment.  We want to adjust up to\n"
"     the same address within the page on the next page up.  */\n"
"  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n"
"  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n"
"  .rodata1        : { *(.rodata1) }\n"
"\n\n"

"/************************************************************************************/\n"
"/* Microsoft .SECTION ordering required for global classes in Torito C Library -->*/\n"
"  .rdata          : { *(SORT_BY_NAME(.CRT$X*)) }\n"
"/************************************************************************************/\n"

"\n\n"
"  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n"
"  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n"
"  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n"
"  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n"
"  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n"
"  /* Adjust the address for the data segment.  We want to adjust up to\n"
"     the same address within the page on the next page up.  */\n"
"  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n"
"  /* Exception handling  */\n"
"  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"
"  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n"
"  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n"
"  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n"
"  /* Thread Local Storage sections  */\n"
"  .tdata	  :\n"
"   {\n"
"     PROVIDE_HIDDEN (__tdata_start = .);\n"
"     *(.tdata .tdata.* .gnu.linkonce.td.*)\n"
"   }\n"
"  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n"
"  .preinit_array    :\n"
"  {\n"
"    PROVIDE_HIDDEN (__preinit_array_start = .);\n"
"    KEEP (*(.preinit_array))\n"
"    PROVIDE_HIDDEN (__preinit_array_end = .);\n"
"  }\n"
"  .init_array    :\n"
"  {\n"
"    PROVIDE_HIDDEN (__init_array_start = .);\n"
"    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n"
"    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n"
"    PROVIDE_HIDDEN (__init_array_end = .);\n"
"  }\n"
"  .fini_array    :\n"
"  {\n"
"    PROVIDE_HIDDEN (__fini_array_start = .);\n"
"    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n"
"    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n"
"    PROVIDE_HIDDEN (__fini_array_end = .);\n"
"  }\n"
"  .ctors          :\n"
"  {\n"
"    /* gcc uses crtbegin.o to find the start of\n"
"       the constructors, so we make sure it is\n"
"       first.  Because this is a wildcard, it\n"
"       doesn't matter if the user does not\n"
"       actually link against crtbegin.o; the\n"
"       linker won't look for a file to match a\n"
"       wildcard.  The wildcard also means that it\n"
"       doesn't matter which directory crtbegin.o\n"
"       is in.  */\n"
"    KEEP (*crtbegin.o(.ctors))\n"
"    KEEP (*crtbegin?.o(.ctors))\n"
"    /* We don't want to include the .ctor section from\n"
"       the crtend.o file until after the sorted ctors.\n"
"       The .ctor section from the crtend file contains the\n"
"       end of ctors marker and it must be last */\n"
"    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n"
"    KEEP (*(SORT(.ctors.*)))\n"
"    KEEP (*(.ctors))\n"
"  }\n"
"  .dtors          :\n"
"  {\n"
"    KEEP (*crtbegin.o(.dtors))\n"
"    KEEP (*crtbegin?.o(.dtors))\n"
"    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n"
"    KEEP (*(SORT(.dtors.*)))\n"
"    KEEP (*(.dtors))\n"
"  }\n"
"  .jcr            : { KEEP (*(.jcr)) }\n"
"  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n"
"  .dynamic        : { *(.dynamic) }\n"
"  .got            : { *(.got) *(.igot) }\n"
"  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n"
"  .got.plt        : { *(.got.plt) *(.igot.plt) }\n"
"  .data           :\n"
"  {\n"
"    *(.data .data.* .gnu.linkonce.d.*)\n"
"    SORT(CONSTRUCTORS)\n"
"  }\n"
"  .data1          : { *(.data1) }\n"
"  _edata = .; PROVIDE (edata = .);\n"
"  . = .;\n"
"  __bss_start = .;\n"
"  .bss            :\n"
"  {\n"
"   *(.dynbss)\n"
"   *(.bss .bss.* .gnu.linkonce.b.*)\n"
"   *(COMMON)\n"
"   /* Align here to ensure that the .bss section occupies space up to\n"
"      _end.  Align after .bss to ensure correct alignment even if the\n"
"      .bss section disappears because there are no input sections.\n"
"      FIXME: Why do we need it? When there is no .bss section, we do not\n"
"      pad the .data section.  */\n"
"   . = ALIGN(. != 0 ? 64 / 8 : 1);\n"
"  }\n"
"  .lbss   :\n"
"  {\n"
"    *(.dynlbss)\n"
"    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n"
"    *(LARGE_COMMON)\n"
"  }\n"
"  . = ALIGN(64 / 8);\n"
"  . = SEGMENT_START(\"ldata-segment\", .);\n"
"  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n"
"  {\n"
"    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n"
"  }\n"
"  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n"
"  {\n"
"    *(.ldata .ldata.* .gnu.linkonce.l.*)\n"
"    . = ALIGN(. != 0 ? 64 / 8 : 1);\n"
"  }\n"
"  . = ALIGN(64 / 8);\n"
"  _end = .; PROVIDE (end = .);\n"
"  . = DATA_SEGMENT_END (.);\n"
"  /* Stabs debugging sections.  */\n"
"  .stab          0 : { *(.stab) }\n"
"  .stabstr       0 : { *(.stabstr) }\n"
"  .stab.excl     0 : { *(.stab.excl) }\n"
"  .stab.exclstr  0 : { *(.stab.exclstr) }\n"
"  .stab.index    0 : { *(.stab.index) }\n"
"  .stab.indexstr 0 : { *(.stab.indexstr) }\n"
"  .comment       0 : { *(.comment) }\n"
"  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n"
"  /* DWARF debug sections.\n"
"     Symbols in the DWARF debugging sections are relative to the beginning\n"
"     of the section so we begin them at 0.  */\n"
"  /* DWARF 1 */\n"
"  .debug          0 : { *(.debug) }\n"
"  .line           0 : { *(.line) }\n"
"  /* GNU DWARF 1 extensions */\n"
"  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n"
"  .debug_sfnames  0 : { *(.debug_sfnames) }\n"
"  /* DWARF 1.1 and DWARF 2 */\n"
"  .debug_aranges  0 : { *(.debug_aranges) }\n"
"  .debug_pubnames 0 : { *(.debug_pubnames) }\n"
"  /* DWARF 2 */\n"
"  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n"
"  .debug_abbrev   0 : { *(.debug_abbrev) }\n"
"  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n"
"  .debug_frame    0 : { *(.debug_frame) }\n"
"  .debug_str      0 : { *(.debug_str) }\n"
"  .debug_loc      0 : { *(.debug_loc) }\n"
"  .debug_macinfo  0 : { *(.debug_macinfo) }\n"
"  /* SGI/MIPS DWARF 2 extensions */\n"
"  .debug_weaknames 0 : { *(.debug_weaknames) }\n"
"  .debug_funcnames 0 : { *(.debug_funcnames) }\n"
"  .debug_typenames 0 : { *(.debug_typenames) }\n"
"  .debug_varnames  0 : { *(.debug_varnames) }\n"
"  /* DWARF 3 */\n"
"  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n"
"  .debug_ranges   0 : { *(.debug_ranges) }\n"
"  /* DWARF Extension.  */\n"
"  .debug_macro    0 : { *(.debug_macro) }\n"
"  .debug_addr     0 : { *(.debug_addr) }\n"
"  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n"
"  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n"
"}"
};